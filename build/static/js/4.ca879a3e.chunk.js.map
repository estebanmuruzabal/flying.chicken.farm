{"version":3,"sources":["modules/state-mgmt/core/actions.ts","modules/state-mgmt/core/epics.ts","modules/state-mgmt/core/index.ts","../../../../src/internal/operators/switchMap.ts","../../../../src/internal/operators/catchError.ts","../../../../src/internal/operators/tap.ts","modules/state-mgmt/todo/actions.ts","modules/state-mgmt/todo/state.ts","modules/state-mgmt/todo/reducer.ts","modules/state-mgmt/todo/epics.ts","modules/state-mgmt/todo/index.ts","modules/views/TodoList/TodoList.tsx","modules/views/TodoList/TodoListContainer.ts"],"names":["ActionType","actions","epicError","error","type","EPIC_ERROR","payload","epics","action$","state$","deps","pipe","ofType","mergeMap","action","of","tap","logger","switchMap","empty","coreState","forEach","epic","EpicRegistry","addEpic","initialState","todoMap","fetchStart","FETCH_START","fetchSuccess","todoList","FETCH_SUCCESS","reducer","state","reduce","total","curr","id","apiService","getTodoList","map","res","catchError","todoState","ReducerRegistry","register","memo","fetchTodoList","useEffect","useMemo","Object","values","className","key","todo","name","description","connect","dispatch","TodoList"],"mappings":"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","file":"static/js/4.ca879a3e.chunk.js","sourcesContent":["export enum ActionType {\n  EPIC_ERROR = '[core] epic error'\n}\n\nexport const actions = {\n  epicError: (error: any) => ({ type: ActionType.EPIC_ERROR, payload: { error } })\n};\n","import { Epic, ofType } from 'redux-observable';\nimport { of, empty } from 'rxjs';\nimport { tap, mergeMap, switchMap } from 'rxjs/operators';\n\nimport { IAction, IRootState, IEpicDependencies } from '../rootState';\nimport { ActionType } from './actions';\n\nexport const handleErrors: Epic<IAction, IAction, IRootState, IEpicDependencies> = (action$, state$, deps) =>\n  action$.pipe(\n    ofType(ActionType.EPIC_ERROR),\n    mergeMap(action =>\n      of(action).pipe(\n        tap(({ payload }) => deps.logger.error(payload.error)),\n        switchMap(() => empty())\n      )\n    )\n  );\n\nexport const epics = [handleErrors];\n","import { EpicRegistry } from '../EpicRegistry';\nimport { actions, ActionType } from './actions';\nimport { epics } from './epics';\n\nexport const coreState = { actions, ActionType, epics };\n\nepics.forEach(epic => EpicRegistry.addEpic(epic));\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { map } from './map';\nimport { from } from '../observable/from';\nexport function switchMap(project, resultSelector) {\n    if (typeof resultSelector === 'function') {\n        return function (source) { return source.pipe(switchMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };\n    }\n    return function (source) { return source.lift(new SwitchMapOperator(project)); };\n}\nvar SwitchMapOperator = /*@__PURE__*/ (function () {\n    function SwitchMapOperator(project) {\n        this.project = project;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n    };\n    return SwitchMapOperator;\n}());\nvar SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project) {\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.index = 0;\n        return _this;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        var innerSubscriber = new InnerSubscriber(this, value, index);\n        var destination = this.destination;\n        destination.add(innerSubscriber);\n        this.innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);\n        if (this.innerSubscription !== innerSubscriber) {\n            destination.add(this.innerSubscription);\n        }\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n        this.unsubscribe();\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        destination.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function catchError(selector) {\n    return function catchErrorOperatorFunction(source) {\n        var operator = new CatchOperator(selector);\n        var caught = source.lift(operator);\n        return (operator.caught = caught);\n    };\n}\nvar CatchOperator = /*@__PURE__*/ (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\nvar CatchSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        var _this = _super.call(this, destination) || this;\n        _this.selector = selector;\n        _this.caught = caught;\n        return _this;\n    }\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                _super.prototype.error.call(this, err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);\n            this.add(innerSubscriber);\n            var innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);\n            if (innerSubscription !== innerSubscriber) {\n                this.add(innerSubscription);\n            }\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=catchError.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\nexport function tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nvar DoOperator = /*@__PURE__*/ (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\nvar TapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(TapSubscriber, _super);\n    function TapSubscriber(destination, observerOrNext, error, complete) {\n        var _this = _super.call(this, destination) || this;\n        _this._tapNext = noop;\n        _this._tapError = noop;\n        _this._tapComplete = noop;\n        _this._tapError = error || noop;\n        _this._tapComplete = complete || noop;\n        if (isFunction(observerOrNext)) {\n            _this._context = _this;\n            _this._tapNext = observerOrNext;\n        }\n        else if (observerOrNext) {\n            _this._context = observerOrNext;\n            _this._tapNext = observerOrNext.next || noop;\n            _this._tapError = observerOrNext.error || noop;\n            _this._tapComplete = observerOrNext.complete || noop;\n        }\n        return _this;\n    }\n    TapSubscriber.prototype._next = function (value) {\n        try {\n            this._tapNext.call(this._context, value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(value);\n    };\n    TapSubscriber.prototype._error = function (err) {\n        try {\n            this._tapError.call(this._context, err);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.error(err);\n    };\n    TapSubscriber.prototype._complete = function () {\n        try {\n            this._tapComplete.call(this._context);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        return this.destination.complete();\n    };\n    return TapSubscriber;\n}(Subscriber));\n//# sourceMappingURL=tap.js.map\n","import { TodoModel } from '../../models';\n\nexport enum ActionType {\n  FETCH_START = '[todo] fetch start',\n  FETCH_SUCCESS = '[todo] fetch success'\n}\n\nexport const actions = {\n  fetchStart: () => ({ type: ActionType.FETCH_START, payload: null }),\n  fetchSuccess: (todoList: TodoModel.ITodo[]) => ({ type: ActionType.FETCH_SUCCESS, payload: { todoList } })\n};\n","import { GeneralModel, TodoModel } from '../../models';\n\nexport interface IState {\n  todoMap: GeneralModel.IEntityMap<TodoModel.ITodo>;\n}\n\nexport const initialState: IState = {\n  todoMap: {}\n};\n","import { ActionType } from './actions';\nimport { initialState, IState } from './state';\n\nexport const reducer = (state: IState = initialState, { type, payload }: { type: ActionType; payload?: any }): IState => {\n  switch (type) {\n    case ActionType.FETCH_SUCCESS:\n      return { ...state, todoMap: payload.todoList.reduce((total, curr) => ({ ...total, [curr.id]: curr }), state.todoMap) };\n    default:\n      return state;\n  }\n};\n","import { Epic, ofType } from 'redux-observable';\nimport { of } from 'rxjs';\nimport { mergeMap, map, catchError } from 'rxjs/operators';\n\nimport { IAction, IRootState, IEpicDependencies } from '../rootState';\nimport { actions, ActionType } from './actions';\nimport { coreState } from '../core';\n\nexport const fetchStart: Epic<IAction, IAction, IRootState, IEpicDependencies> = (action$, state$, deps) =>\n  action$.pipe(\n    ofType(ActionType.FETCH_START),\n    mergeMap(action =>\n      of(action).pipe(\n        mergeMap(() => deps.apiService.getTodoList()),\n        map(res => actions.fetchSuccess(res)),\n        catchError(error => of(coreState.actions.epicError(error)))\n      )\n    )\n  );\n\nexport const epics = [fetchStart];\n","import { EpicRegistry } from '../EpicRegistry';\nimport { ReducerRegistry } from '../ReducerRegistry';\nimport { initialState } from './state';\nimport { actions, ActionType } from './actions';\nimport { reducer } from './reducer';\nimport { epics } from './epics';\n\nexport const todoState = { initialState, reducer, actions, ActionType, epics };\n\nReducerRegistry.register('todo', reducer);\nepics.forEach(epic => EpicRegistry.addEpic(epic));\n","import React, { memo, useMemo, useEffect } from 'react';\n\nimport { GeneralModel, TodoModel } from '../../models';\n\nexport interface ITodoListProps {\n  todoMap: GeneralModel.IEntityMap<TodoModel.ITodo>;\n  fetchTodoList: () => void;\n}\n\nconst TodoList = ({ todoMap, fetchTodoList }: ITodoListProps) => {\n  useEffect(() => {\n    fetchTodoList();\n  }, []); // eslint-disable-line\n\n  const todoList = useMemo(() => Object.values(todoMap), [todoMap]);\n  return (\n    <div className=\"container\" key=\"TodoList\">\n      <table className=\"table\">\n        <thead>\n          <tr>\n            <th>ID</th>\n            <th>name</th>\n            <th>description</th>\n          </tr>\n        </thead>\n        <tbody>\n          {todoList.map(todo => (\n            <tr key={todo.id}>\n              <td>{todo.id}</td>\n              <td>{todo.name}</td>\n              <td>{todo.description}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport default memo(TodoList);\n","import { connect } from 'react-redux';\n\nimport { IRootState } from '../../state-mgmt/rootState';\nimport { todoState } from '../../state-mgmt/todo';\nimport TodoList from './TodoList';\n\nexport const mapStateToProps = (state: IRootState) => ({\n  todoMap: state.todo.todoMap\n});\n\nexport const mapDispatchToProps = dispatch => ({\n  fetchTodoList: () => dispatch(todoState.actions.fetchStart())\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoList);\n"],"sourceRoot":""}